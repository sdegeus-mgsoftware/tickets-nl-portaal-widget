<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual Feedback Test</title>
  <style>
    body {
      margin: 0;
      padding: 40px;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 40px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }
    
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .test-content {
      margin-bottom: 40px;
    }
    
    .test-button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 10px;
    }
    
    .test-button:hover {
      background: #2563eb;
      transform: translateY(-2px);
    }
    
    .help-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #3b82f6;
      color: white;
      border: none;
      padding: 15px 20px;
      border-radius: 25px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
      transition: all 0.3s ease;
      z-index: 1000;
    }
    
    .help-button:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
    }

    /* Floating Stop Recording Button */
    .stop-recording-floating {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 999999;
      background: #ef4444;
      color: white;
      border: 3px solid #fef2f2;
      border-radius: 50px;
      padding: 18px 28px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 180px;
      justify-content: center;
      animation: float 3s ease-in-out infinite;
    }

    .stop-recording-floating:hover {
      background: #dc2626;
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 12px 30px rgba(239, 68, 68, 0.5);
      border-color: #fff;
    }

    .recording-pulse {
      width: 14px;
      height: 14px;
      background: #fef2f2;
      border-radius: 50%;
      animation: pulse 1.2s infinite;
    }

    .stop-icon {
      font-size: 18px;
      animation: blink 2s infinite;
    }

    .stop-text {
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    @keyframes float {
      0%, 100% { 
        transform: translateY(0px); 
      }
      50% { 
        transform: translateY(-5px); 
      }
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.7; }
    }

    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.4; 
        transform: scale(1.2);
      }
    }
    
    /* Simple Visual Feedback Modal Styles */
    .visual-feedback-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: Arial, sans-serif;
    }
    
         .visual-feedback-content {
       background: white;
       border-radius: 0;
       width: 100%;
       height: 100vh;
       overflow: hidden;
       display: flex;
       flex-direction: column;
     }
    
    .visual-feedback-header {
      padding: 20px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .visual-feedback-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6b7280;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    .visual-feedback-close:hover {
      background: #f3f4f6;
    }
    
         .feedback-main {
       flex: 1;
       display: flex;
       padding: 0;
       gap: 0;
     }
     
     .screenshot-panel {
       flex: 1;
       display: flex;
       flex-direction: column;
       position: relative;
     }
     
     .drawing-tools {
       display: flex;
       gap: 15px;
       padding: 15px;
       background: #f8f9fa;
       border-bottom: 1px solid #e5e7eb;
       align-items: center;
       flex-wrap: wrap;
     }
     
     .tool-group {
       display: flex;
       gap: 8px;
       align-items: center;
     }
     
     .tool-label {
       font-size: 14px;
       font-weight: 500;
       color: #374151;
       margin-right: 8px;
     }
     
     .tool-btn {
       padding: 8px 12px;
       border: 2px solid #d1d5db;
       background: white;
       border-radius: 6px;
       cursor: pointer;
       font-size: 14px;
       transition: all 0.2s ease;
       display: flex;
       align-items: center;
       gap: 5px;
       min-width: 80px;
       justify-content: center;
     }
     
     .tool-btn:hover {
       background: #f3f4f6;
       border-color: #9ca3af;
     }
     
     .tool-btn.active {
       background: #3b82f6;
       color: white;
       border-color: #3b82f6;
     }
     
     .color-picker {
       width: 40px;
       height: 40px;
       border: 2px solid #d1d5db;
       border-radius: 6px;
       cursor: pointer;
       background: #ef4444;
     }
     
     .color-options {
       display: flex;
       gap: 8px;
     }
     
     .color-option {
       width: 30px;
       height: 30px;
       border: 2px solid #d1d5db;
       border-radius: 4px;
       cursor: pointer;
       transition: all 0.2s ease;
     }
     
     .color-option:hover {
       transform: scale(1.1);
       border-color: #6b7280;
     }
     
     .color-option.active {
       border-color: #1f2937;
       border-width: 3px;
     }
     
     .screenshot-container {
       flex: 1;
       background: #f8f9fa;
       border-radius: 0;
       position: relative;
       overflow: auto;
       min-height: 400px;
       display: flex;
       align-items: flex-start;
       justify-content: flex-start;
       padding: 20px;
       scroll-behavior: smooth;
     }
     
     .screenshot-container::-webkit-scrollbar {
       width: 12px;
       height: 12px;
     }
     
     .screenshot-container::-webkit-scrollbar-track {
       background: #f1f5f9;
       border-radius: 6px;
     }
     
     .screenshot-container::-webkit-scrollbar-thumb {
       background: #cbd5e1;
       border-radius: 6px;
       border: 2px solid #f1f5f9;
     }
     
     .screenshot-container::-webkit-scrollbar-thumb:hover {
       background: #94a3b8;
     }
     
     #screenshotCanvas {
       border-radius: 4px;
       cursor: crosshair;
       box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
       background: white;
       display: block;
     }
    
         .chat-panel {
       width: 400px;
       display: flex;
       flex-direction: column;
       border-left: 1px solid #e5e7eb;
       padding: 20px;
       background: white;
       position: relative;
       flex-shrink: 0;
     }
    
    .chat-messages {
      flex: 1;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      overflow-y: auto;
      margin-bottom: 15px;
      min-height: 200px;
    }
    
    .ai-message {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .message-content {
      background: white;
      padding: 10px 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .chat-input-container {
      display: flex;
      gap: 10px;
    }
    
    .chat-input-container textarea {
      flex: 1;
      padding: 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      resize: vertical;
      min-height: 60px;
      font-family: inherit;
    }
    
    .send-btn {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      align-self: flex-end;
    }
    
    .send-btn:hover {
      background: #2563eb;
    }
    
    .screenshot-loading {
      text-align: center;
      padding: 40px;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e5e7eb;
      border-top: 3px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Collapsible log sections */
    .log-section {
      margin: 10px 0;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
    }

    .log-header {
      background: #f8f9fa;
      padding: 8px 12px;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      font-weight: 500;
      transition: background-color 0.2s ease;
    }

    .log-header:hover {
      background: #f1f5f9;
    }

    .log-header .arrow {
      transition: transform 0.2s ease;
      font-size: 12px;
    }

    .log-header.expanded .arrow {
      transform: rotate(90deg);
    }

    .log-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: #fafafa;
    }

    .log-content.expanded {
      max-height: 300px;
      overflow-y: auto;
    }

    .log-entries {
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      line-height: 1.4;
    }

    .log-entry {
      margin-bottom: 8px;
      padding: 4px 6px;
      border-radius: 3px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-entry.error {
      background: #fef2f2;
      border-left: 3px solid #ef4444;
      color: #dc2626;
    }

    .log-entry.warn {
      background: #fffbeb;
      border-left: 3px solid #f59e0b;
      color: #d97706;
    }

    .log-entry.info {
      background: #eff6ff;
      border-left: 3px solid #3b82f6;
      color: #2563eb;
    }

    .log-entry.log {
      background: #f9fafb;
      border-left: 3px solid #6b7280;
      color: #374151;
    }

    .log-timestamp {
      color: #9ca3af;
      font-size: 10px;
    }

    .network-entry {
      margin-bottom: 6px;
      padding: 4px 6px;
      border-radius: 3px;
      background: #f9fafb;
      font-size: 11px;
    }

    .network-entry.success {
      border-left: 3px solid #10b981;
    }

    .network-entry.error {
      border-left: 3px solid #ef4444;
    }

    .network-entry.pending {
      border-left: 3px solid #f59e0b;
    }

    .network-status {
      font-weight: 500;
      margin-right: 8px;
    }

    .network-url {
      color: #6b7280;
      word-break: break-all;
    }

    .network-main {
      margin-bottom: 8px;
    }

    .network-details {
      margin-left: 16px;
      border-left: 2px solid #e5e7eb;
      padding-left: 8px;
    }

    .network-details .log-section {
      margin: 4px 0;
    }

    .network-details .log-header {
      background: #f1f5f9;
      font-size: 11px;
      padding: 4px 8px;
    }

    .network-details pre {
      background: #f8f9fa;
      padding: 4px 6px;
      border-radius: 3px;
      border: 1px solid #e5e7eb;
      font-size: 10px;
      line-height: 1.3;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 2px 0;
    }

    .network-details .log-entries {
      padding: 6px;
    }

    /* Replication Recording Styles */
    .replication-controls {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .replication-header h4 {
      color: #1e293b;
      margin: 0 0 4px 0;
    }

    .replication-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .replication-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .replication-btn:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .replication-btn.start-recording {
      border-color: #10b981;
      color: #065f46;
    }

    .replication-btn.start-recording:hover {
      background: #ecfdf5;
      border-color: #059669;
    }

    .replication-btn.stop-recording {
      border-color: #ef4444;
      color: #991b1b;
    }

    .replication-btn.stop-recording:hover {
      background: #fef2f2;
      border-color: #dc2626;
    }

    .recording-status {
      margin-top: 12px;
      padding: 12px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 6px;
    }

    .recording-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-weight: 500;
      color: #991b1b;
    }

    .recording-dot {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .recorded-steps {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .recorded-steps h5 {
      margin: 0 0 8px 0;
      color: #374151;
      font-size: 13px;
    }

    .recorded-steps ol {
      margin: 0;
      padding-left: 20px;
      font-size: 12px;
      line-height: 1.4;
    }

    .recorded-steps li {
      margin-bottom: 4px;
      color: #6b7280;
    }

    .step-time {
      color: #9ca3af;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Visual Feedback Widget Test</h1>
    
    <div class="test-content">
      <p><strong>Test the new visual feedback functionality:</strong></p>
      <p>This page demonstrates the visual feedback widget that takes a screenshot and allows annotation with a chat interface.</p>
      
      <h3>Sample Content to Test</h3>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
      <div style="background: #f0f0f0; padding: 20px; margin: 20px 0; border-radius: 8px;">
        <h4>Sample Box</h4>
        <p>This is a sample element you can annotate in the screenshot.</p>
        <button class="test-button">Sample Button</button>
      </div>
      
      <p>Click the "Need Help?" button in the bottom-right corner to test the visual feedback modal.</p>
    </div>
  </div>
  
  <!-- Floating Help Button -->
  <button class="help-button" onclick="showVisualFeedback()" title="Report issue with screenshot, logs & system info">Need Help? üéØ</button>
  
  <!-- Floating Stop Recording Button -->
  <button class="stop-recording-floating" id="stopRecordingFloating" onclick="stopReplication()" style="display: none;" title="Stop step recording and return to feedback form">
    <span class="recording-pulse"></span>
    <span class="stop-icon">üî¥</span>
    <span class="stop-text">Stop Recording</span>
  </button>
  
  <!-- Visual Feedback Modal -->
  <div class="visual-feedback-modal" id="visualFeedbackModal">
    <div class="visual-feedback-content">
      <div class="visual-feedback-header">
        <h3>Visual Feedback</h3>
        <button class="visual-feedback-close" onclick="hideVisualFeedback()">√ó</button>
      </div>
      
      <div class="visual-feedback-body">
        <div class="screenshot-loading" id="screenshotLoading">
          <div class="loading-spinner"></div>
          <p id="loadingText">Preparing to capture...</p>
        </div>
        
                 <div class="feedback-main" id="feedbackMain" style="display: none;">
           <div class="screenshot-panel">
             <!-- Drawing Tools -->
             <div class="drawing-tools">
               <div class="tool-group">
                 <span class="tool-label">Tools:</span>
                 <button class="tool-btn active" data-tool="pen">‚úèÔ∏è Pen</button>
                 <button class="tool-btn" data-tool="rectangle">‚¨ú Rectangle</button>
                 <button class="tool-btn" data-tool="arrow">‚ÜóÔ∏è Arrow</button>
               </div>
               
               <div class="tool-group">
                 <span class="tool-label">Color:</span>
                 <div class="color-options">
                   <div class="color-option active" data-color="#ef4444" style="background: #ef4444;"></div>
                   <div class="color-option" data-color="#3b82f6" style="background: #3b82f6;"></div>
                   <div class="color-option" data-color="#10b981" style="background: #10b981;"></div>
                   <div class="color-option" data-color="#f59e0b" style="background: #f59e0b;"></div>
                   <div class="color-option" data-color="#8b5cf6" style="background: #8b5cf6;"></div>
                   <div class="color-option" data-color="#000000" style="background: #000000;"></div>
                 </div>
               </div>
               
               <div class="tool-group">
                 <button class="tool-btn" onclick="clearAnnotations()">üóëÔ∏è Clear</button>
                 <button class="tool-btn" onclick="undoAnnotation()" title="Undo last annotation (Ctrl+Z)">‚Ü∂ Undo</button>
               </div>
               
               <div class="tool-group">
                 <span class="tool-label" style="color: #059669; font-weight: 600;">üìê 1:1 Scale</span>
                 <small style="color: #6b7280;">Scroll to navigate ‚Ä¢ Full resolution editing</small>
                 <small id="dimensionsDisplay" style="color: #6b7280; margin-left: 10px;"></small>
               </div>
             </div>
             
             <div class="screenshot-container">
               <canvas id="screenshotCanvas"></canvas>
             </div>
           </div>
          
          <div class="chat-panel">
                         <div class="chat-header" style="margin-bottom: 20px;">
               <h4 style="margin: 0 0 8px 0; font-size: 18px;">Describe the issue</h4>
               <small style="color: #6b7280;">Use the drawing tools to annotate the screenshot, then explain what's wrong or what you need help with</small>
             </div>
            
            <div class="chat-messages" id="chatMessages">
              <div class="ai-message">
                <div class="message-avatar">ü§ñ</div>
                <div class="message-content">
                  <p>Hi! I can see you've taken a screenshot. Please describe what issue you're experiencing or what help you need.</p>
                </div>
              </div>
            </div>
            
            <div class="replication-controls" id="replicationControls">
              <div class="replication-header">
                <h4 style="margin: 0 0 8px 0; font-size: 16px;">üé¨ Step Replication</h4>
                <small style="color: #6b7280;">Record your steps to help reproduce the issue</small>
              </div>
              
              <div class="replication-buttons">
                <button class="replication-btn start-recording" id="startRecordingBtn" onclick="startReplication()">
                  <span class="btn-icon">üé•</span>
                  Start Recording Steps
                </button>
                <button class="replication-btn stop-recording" id="stopRecordingBtn" onclick="stopReplication()" style="display: none;">
                  <span class="btn-icon">‚èπÔ∏è</span>
                  Stop Recording
                </button>
              </div>
              
              <div class="recording-status" id="recordingStatus" style="display: none;">
                <div class="recording-indicator">
                  <span class="recording-dot"></span>
                  <span>Recording in progress...</span>
                </div>
                <div class="recorded-steps" id="recordedSteps">
                  <h5>Recorded Steps:</h5>
                  <ol id="stepsList"></ol>
                </div>
              </div>
            </div>
            
            <div class="chat-input-container">
              <textarea id="chatInput" placeholder="Describe the issue you're experiencing..." rows="3"></textarea>
              <button class="send-btn" onclick="sendMessage()">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
     <script>
     let chatMessages = [];
     let canvas, ctx;
     let isDrawing = false;
     let currentTool = 'pen';
     let currentColor = '#ef4444';
     let annotations = [];
     let currentAnnotation = null;
     let startX, startY;
     let originalImageData = null;
     let systemInfo = null;
     let capturedLogs = [];
     let networkLogs = [];
     
     // Replication recording variables
     let mediaRecorder = null;
     let recordedChunks = [];
     let replicationSteps = [];
     let isRecording = false;
     let recordingStartTime = null;
     let stepListeners = [];

     // Capture console logs from page load
     (function setupConsoleCapture() {
       const originalConsole = {
         log: console.log,
         error: console.error,
         warn: console.warn,
         info: console.info,
         debug: console.debug
       };

       function captureLog(level, args) {
         const timestamp = new Date().toISOString();
         const message = Array.from(args).map(arg => {
           if (typeof arg === 'object') {
             try {
               return JSON.stringify(arg, null, 2);
             } catch(e) {
               return String(arg);
             }
           }
           return String(arg);
         }).join(' ');

         capturedLogs.push({
           level,
           message,
           timestamp,
           stack: level === 'error' ? new Error().stack : null
         });

         // Keep only last 50 logs to prevent memory issues
         if (capturedLogs.length > 50) {
           capturedLogs = capturedLogs.slice(-50);
         }
       }

       // Override console methods
       console.log = function(...args) {
         captureLog('log', args);
         originalConsole.log.apply(console, args);
       };

       console.error = function(...args) {
         captureLog('error', args);
         originalConsole.error.apply(console, args);
       };

       console.warn = function(...args) {
         captureLog('warn', args);
         originalConsole.warn.apply(console, args);
       };

       console.info = function(...args) {
         captureLog('info', args);
         originalConsole.info.apply(console, args);
       };

       console.debug = function(...args) {
         captureLog('debug', args);
         originalConsole.debug.apply(console, args);
       };

       // Capture unhandled errors
       window.addEventListener('error', function(event) {
         captureLog('error', [`Uncaught Error: ${event.message}`, `File: ${event.filename}:${event.lineno}:${event.colno}`, event.error]);
       });

       // Capture promise rejections
       window.addEventListener('unhandledrejection', function(event) {
         captureLog('error', [`Unhandled Promise Rejection: ${event.reason}`]);
       });
     })();

     // Replication Recording Functions
     async function startReplication() {
       try {
         // Request screen capture permission
         const stream = await navigator.mediaDevices.getDisplayMedia({
           video: {
             mediaSource: 'screen',
             width: { ideal: 1920 },
             height: { ideal: 1080 }
           },
           audio: false
         });

         // Set up MediaRecorder
         mediaRecorder = new MediaRecorder(stream, {
           mimeType: 'video/webm;codecs=vp9'
         });

         recordedChunks = [];
         replicationSteps = [];
         recordingStartTime = Date.now();
         isRecording = true;

         // Handle recorded data
         mediaRecorder.addEventListener('dataavailable', event => {
           if (event.data.size > 0) {
             recordedChunks.push(event.data);
           }
         });

         // Handle recording stop
         mediaRecorder.addEventListener('stop', () => {
           const blob = new Blob(recordedChunks, { type: 'video/webm' });
           const videoUrl = URL.createObjectURL(blob);
           
           // Add video to replication data
           systemInfo.replicationData = {
             videoUrl: videoUrl,
             videoBlob: blob,
             steps: replicationSteps,
             duration: Date.now() - recordingStartTime
           };

           console.log('Screen recording completed:', {
             duration: systemInfo.replicationData.duration,
             steps: replicationSteps.length,
             videoSize: blob.size
           });
         });

         // Start recording
         mediaRecorder.start();

         // Set up interaction tracking
         setupInteractionTracking();

         // Update UI - hide modal and show floating stop button
         document.getElementById('startRecordingBtn').style.display = 'none';
         document.getElementById('stopRecordingBtn').style.display = 'inline-flex';
         document.getElementById('recordingStatus').style.display = 'block';
         
         // Hide the modal and show floating stop button
         document.getElementById('visualFeedbackModal').style.display = 'none';
         document.getElementById('stopRecordingFloating').style.display = 'flex';

         // Add initial step
         addReplicationStep('üé¨ Started recording user interactions');
         
         // Add instructions to chat
         addChatMessage('ai', `üé¨ **Recording Started!**

The modal has been minimized so you can interact with the page. 

üìπ **Screen recording is active**
üìù **All your interactions are being tracked**
üî¥ **Look for the red "Stop Recording" button** at the bottom-right

**Go ahead and reproduce the issue** - click, scroll, type, or do whatever causes the problem. When you're done, click the floating "Stop Recording" button to return to this feedback form.`);

         // Handle stream end (user stops sharing)
         stream.getVideoTracks()[0].addEventListener('ended', () => {
           if (isRecording) {
             stopReplication();
           }
         });

       } catch (error) {
         console.error('Error starting screen recording:', error);
         alert('Unable to start screen recording. Please ensure you grant permission to capture your screen.');
       }
     }

     function stopReplication() {
       if (!isRecording) return;

       isRecording = false;

       // Stop media recorder
       if (mediaRecorder && mediaRecorder.state !== 'inactive') {
         mediaRecorder.stop();
       }

       // Remove interaction listeners
       removeInteractionTracking();

               // Update UI - show modal again and hide floating button
        document.getElementById('startRecordingBtn').style.display = 'inline-flex';
        document.getElementById('stopRecordingBtn').style.display = 'none';
        document.getElementById('recordingStatus').style.display = 'none';
        document.getElementById('stopRecordingFloating').style.display = 'none';
        document.getElementById('visualFeedbackModal').style.display = 'flex';

        // Add final step
        addReplicationStep('‚èπÔ∏è Stopped recording');

        // Show completion message
        const duration = Math.round((Date.now() - recordingStartTime) / 1000);
        addChatMessage('ai', `‚úÖ **Recording Complete!**

üìπ **Screen Recording:** ${duration}s video captured
üìù **Steps Recorded:** ${replicationSteps.length} interactions tracked
üéØ **Ready for Submission:** Your replication data is now included with the feedback

The recording and step-by-step interactions will be sent along with your feedback to help developers reproduce the issue exactly as you experienced it.`);
     }

     function setupInteractionTracking() {
       // Track clicks on the main page
       const clickListener = (e) => {
         if (e.target.closest('.visual-feedback-modal')) return; // Ignore clicks in modal
         
         const element = e.target;
         const rect = element.getBoundingClientRect();
         const selector = generateSelector(element);
         
         addReplicationStep(`üñ±Ô∏è Clicked: ${selector} at (${Math.round(rect.left + rect.width/2)}, ${Math.round(rect.top + rect.height/2)})`);
       };

       // Track scrolling
       const scrollListener = debounce(() => {
         addReplicationStep(`üìú Scrolled to: (${window.scrollX}, ${window.scrollY})`);
       }, 500);

       // Track key presses
       const keyListener = (e) => {
         if (e.target.closest('.visual-feedback-modal')) return; // Ignore keys in modal
         
         const key = e.key;
         const element = e.target;
         const selector = generateSelector(element);
         
         if (key.length === 1) {
           addReplicationStep(`‚å®Ô∏è Typed '${key}' in: ${selector}`);
         } else if (['Enter', 'Tab', 'Escape', 'Backspace', 'Delete'].includes(key)) {
           addReplicationStep(`‚å®Ô∏è Pressed ${key} in: ${selector}`);
         }
       };

       // Track form interactions
       const changeListener = (e) => {
         if (e.target.closest('.visual-feedback-modal')) return; // Ignore changes in modal
         
         const element = e.target;
         const selector = generateSelector(element);
         const value = element.value;
         
         addReplicationStep(`üìù Changed ${selector} to: "${value.substring(0, 50)}${value.length > 50 ? '...' : ''}"`);
       };

       // Add listeners to document
       document.addEventListener('click', clickListener, true);
       document.addEventListener('scroll', scrollListener, true);
       document.addEventListener('keydown', keyListener, true);
       document.addEventListener('change', changeListener, true);

       // Store listeners for cleanup
       stepListeners = [
         { type: 'click', listener: clickListener },
         { type: 'scroll', listener: scrollListener },
         { type: 'keydown', listener: keyListener },
         { type: 'change', listener: changeListener }
       ];
     }

     function removeInteractionTracking() {
       stepListeners.forEach(({ type, listener }) => {
         document.removeEventListener(type, listener, true);
       });
       stepListeners = [];
     }

     function addReplicationStep(description) {
       const timestamp = Date.now();
       const relativeTime = recordingStartTime ? Math.round((timestamp - recordingStartTime) / 1000) : 0;
       
       const step = {
         description,
         timestamp,
         relativeTime
       };
       
       replicationSteps.push(step);
       
       // Update UI
       const stepsList = document.getElementById('stepsList');
       const li = document.createElement('li');
       li.innerHTML = `${description} <span class="step-time">(${relativeTime}s)</span>`;
       stepsList.appendChild(li);
       
       // Scroll to bottom
       const recordedSteps = document.getElementById('recordedSteps');
       recordedSteps.scrollTop = recordedSteps.scrollHeight;
     }

     function generateSelector(element) {
       if (element.id) return `#${element.id}`;
       if (element.className) return `.${element.className.split(' ')[0]}`;
       return element.tagName.toLowerCase();
     }

     function debounce(func, wait) {
       let timeout;
       return function executedFunction(...args) {
         const later = () => {
           clearTimeout(timeout);
           func(...args);
         };
         clearTimeout(timeout);
         timeout = setTimeout(later, wait);
       };
     }

     // Capture network requests
     (function setupNetworkCapture() {
       const originalFetch = window.fetch;
       const originalXMLHttpRequest = window.XMLHttpRequest;

       // Override fetch
       window.fetch = function(...args) {
         const startTime = Date.now();
         const url = args[0];
         const options = args[1] || {};

         // Capture request details
         const requestData = {
           type: 'fetch',
           method: options.method || 'GET',
           url: url,
           timestamp: new Date().toISOString(),
           status: 'pending',
           requestHeaders: options.headers || {},
           requestBody: null,
           responseHeaders: null,
           responseBody: null
         };

         // Capture request body
         if (options.body) {
           try {
             if (typeof options.body === 'string') {
               requestData.requestBody = options.body;
             } else if (options.body instanceof FormData) {
               requestData.requestBody = '[FormData]';
               // Try to extract FormData entries
               const formDataEntries = {};
               for (let [key, value] of options.body.entries()) {
                 formDataEntries[key] = value instanceof File ? `[File: ${value.name}]` : value;
               }
               requestData.requestBody = JSON.stringify(formDataEntries, null, 2);
             } else if (options.body instanceof URLSearchParams) {
               requestData.requestBody = options.body.toString();
             } else {
               requestData.requestBody = '[Binary Data]';
             }
           } catch (e) {
             requestData.requestBody = '[Could not capture body]';
           }
         }

         networkLogs.push(requestData);

         return originalFetch.apply(this, args)
           .then(response => {
             const duration = Date.now() - startTime;
             const logEntry = networkLogs.find(log => log.url === url && log.status === 'pending');
             if (logEntry) {
               logEntry.status = response.status;
               logEntry.statusText = response.statusText;
               logEntry.duration = duration;
               logEntry.size = response.headers.get('content-length') || 'unknown';
               
               // Capture response headers
               const responseHeaders = {};
               for (let [key, value] of response.headers.entries()) {
                 responseHeaders[key] = value;
               }
               logEntry.responseHeaders = responseHeaders;

               // Try to capture response body (clone to avoid consuming it)
               const responseClone = response.clone();
               responseClone.text().then(text => {
                 if (text.length < 5000) { // Only capture small responses
                   logEntry.responseBody = text;
                 } else {
                   logEntry.responseBody = `[Large Response: ${text.length} chars]`;
                 }
               }).catch(() => {
                 logEntry.responseBody = '[Could not capture response]';
               });
             }
             return response;
           })
           .catch(error => {
             const duration = Date.now() - startTime;
             const logEntry = networkLogs.find(log => log.url === url && log.status === 'pending');
             if (logEntry) {
               logEntry.status = 'failed';
               logEntry.error = error.message;
               logEntry.duration = duration;
             }
             throw error;
           });
       };

       // Override XMLHttpRequest
       const originalOpen = originalXMLHttpRequest.prototype.open;
       const originalSend = originalXMLHttpRequest.prototype.send;
       const originalSetRequestHeader = originalXMLHttpRequest.prototype.setRequestHeader;

       originalXMLHttpRequest.prototype.open = function(method, url, async, user, password) {
         this._captureData = {
           method: method,
           url: url,
           timestamp: new Date().toISOString(),
           startTime: Date.now(),
           requestHeaders: {},
           requestBody: null,
           responseHeaders: null,
           responseBody: null
         };
         return originalOpen.apply(this, arguments);
       };

       originalXMLHttpRequest.prototype.setRequestHeader = function(header, value) {
         if (this._captureData) {
           this._captureData.requestHeaders[header] = value;
         }
         return originalSetRequestHeader.apply(this, arguments);
       };

       originalXMLHttpRequest.prototype.send = function(data) {
         if (this._captureData) {
           // Capture request body
           if (data) {
             try {
               if (typeof data === 'string') {
                 this._captureData.requestBody = data;
               } else if (data instanceof FormData) {
                 this._captureData.requestBody = '[FormData]';
                 // Try to extract FormData entries
                 const formDataEntries = {};
                 for (let [key, value] of data.entries()) {
                   formDataEntries[key] = value instanceof File ? `[File: ${value.name}]` : value;
                 }
                 this._captureData.requestBody = JSON.stringify(formDataEntries, null, 2);
               } else if (data instanceof URLSearchParams) {
                 this._captureData.requestBody = data.toString();
               } else {
                 this._captureData.requestBody = '[Binary Data]';
               }
             } catch (e) {
               this._captureData.requestBody = '[Could not capture body]';
             }
           }

           networkLogs.push({
             type: 'xhr',
             method: this._captureData.method,
             url: this._captureData.url,
             timestamp: this._captureData.timestamp,
             status: 'pending',
             requestHeaders: this._captureData.requestHeaders,
             requestBody: this._captureData.requestBody,
             responseHeaders: null,
             responseBody: null
           });

           this.addEventListener('loadend', () => {
             const duration = Date.now() - this._captureData.startTime;
             const logEntry = networkLogs.find(log => 
               log.url === this._captureData.url && 
               log.timestamp === this._captureData.timestamp &&
               log.status === 'pending'
             );
             if (logEntry) {
               logEntry.status = this.status;
               logEntry.statusText = this.statusText;
               logEntry.duration = duration;
               logEntry.size = this.getResponseHeader('content-length') || 'unknown';
               
               // Capture response headers
               const responseHeaders = {};
               const headerString = this.getAllResponseHeaders();
               if (headerString) {
                 headerString.split('\r\n').forEach(line => {
                   const [key, value] = line.split(': ');
                   if (key && value) {
                     responseHeaders[key] = value;
                   }
                 });
               }
               logEntry.responseHeaders = responseHeaders;

               // Capture response body
               const responseText = this.responseText;
               if (responseText && responseText.length < 5000) {
                 logEntry.responseBody = responseText;
               } else if (responseText) {
                 logEntry.responseBody = `[Large Response: ${responseText.length} chars]`;
               }
             }
           });
         }
         return originalSend.apply(this, arguments);
       };

       // Keep only last 30 network logs
       setInterval(() => {
         if (networkLogs.length > 30) {
           networkLogs = networkLogs.slice(-30);
         }
       }, 10000);
     })();

     // Gather system information
     async function gatherSystemInfo() {
       try {
         // Get IP address
         let ipAddress = 'Unable to detect';
         try {
           const ipResponse = await fetch('https://api.ipify.org?format=json');
           const ipData = await ipResponse.json();
           ipAddress = ipData.ip;
         } catch (e) {
           console.log('Could not fetch IP address');
         }

         // Detect browser with version
         const userAgent = navigator.userAgent;
         let browser = 'Unknown Browser';
         let browserVersion = 'Unknown';
         
         if (userAgent.includes('Chrome') && !userAgent.includes('Edg')) {
           browser = 'Google Chrome';
           const chromeMatch = userAgent.match(/Chrome\/([0-9.]+)/);
           browserVersion = chromeMatch ? chromeMatch[1] : 'Unknown';
         } else if (userAgent.includes('Firefox')) {
           browser = 'Mozilla Firefox';
           const firefoxMatch = userAgent.match(/Firefox\/([0-9.]+)/);
           browserVersion = firefoxMatch ? firefoxMatch[1] : 'Unknown';
         } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
           browser = 'Safari';
           const safariMatch = userAgent.match(/Version\/([0-9.]+)/);
           browserVersion = safariMatch ? safariMatch[1] : 'Unknown';
         } else if (userAgent.includes('Edg')) {
           browser = 'Microsoft Edge';
           const edgeMatch = userAgent.match(/Edg\/([0-9.]+)/);
           browserVersion = edgeMatch ? edgeMatch[1] : 'Unknown';
         }

         // Detect OS
         let os = 'Unknown OS';
         if (userAgent.includes('Windows')) {
           os = 'Windows';
         } else if (userAgent.includes('Mac')) {
           os = 'macOS';
         } else if (userAgent.includes('Linux')) {
           os = 'Linux';
         } else if (userAgent.includes('Android')) {
           os = 'Android';
         } else if (userAgent.includes('iOS')) {
           os = 'iOS';
         }

         systemInfo = {
           // Page info
           url: window.location.href,
           referrer: document.referrer || 'Direct access',
           
           // Browser info
           browser: browser,
           browserVersion: browserVersion,
           userAgent: userAgent,
           
           // System info
           os: os,
           platform: navigator.platform || 'Unknown',
           language: navigator.language || 'Unknown',
           languages: navigator.languages ? navigator.languages.join(', ') : 'Unknown',
           timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown',
           
           // Display info
           screenWidth: screen.width,
           screenHeight: screen.height,
           screenColorDepth: screen.colorDepth,
           viewportWidth: window.innerWidth,
           viewportHeight: window.innerHeight,
           devicePixelRatio: window.devicePixelRatio || 1,
           
           // Hardware info  
           hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
           deviceMemory: navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'Unknown',
           
           // Network info
           ip: ipAddress,
           connectionType: navigator.connection ? navigator.connection.effectiveType || 'Unknown' : 'Unknown',
           
           // Storage support
           cookieEnabled: navigator.cookieEnabled,
           localStorageSupported: (() => {
             try {
               return typeof(Storage) !== "undefined";
             } catch(e) {
               return false;
             }
           })(),
           
           // Touch support
           touchSupported: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
           maxTouchPoints: navigator.maxTouchPoints || 0,
           
           // Timing
           timestamp: new Date().toISOString(),
           timezoneOffset: new Date().getTimezoneOffset(),

           // Debug info
           consoleLogs: [...capturedLogs],
           networkLogs: [...networkLogs]
         };

         return systemInfo;
       } catch (error) {
         console.error('Error gathering system info:', error);
         return {
           // Page info
           url: window.location.href,
           referrer: document.referrer || 'Direct access',
           
           // Browser info (fallback)
           browser: 'Detection failed',
           browserVersion: 'Unknown',
           userAgent: navigator.userAgent,
           
           // System info (fallback)
           os: 'Detection failed',
           platform: navigator.platform || 'Unknown',
           language: navigator.language || 'Unknown',
           languages: navigator.languages ? navigator.languages.join(', ') : 'Unknown',
           timezone: 'Unknown',
           
           // Display info (still available)
           screenWidth: screen.width,
           screenHeight: screen.height,
           screenColorDepth: screen.colorDepth,
           viewportWidth: window.innerWidth,
           viewportHeight: window.innerHeight,
           devicePixelRatio: window.devicePixelRatio || 1,
           
           // Hardware info
           hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
           deviceMemory: 'Unknown',
           
           // Network info (fallback)
           ip: 'Detection failed',
           connectionType: 'Unknown',
           
           // Storage support
           cookieEnabled: navigator.cookieEnabled,
           localStorageSupported: false,
           
           // Touch support
           touchSupported: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
           maxTouchPoints: navigator.maxTouchPoints || 0,
           
           // Timing
           timestamp: new Date().toISOString(),
           timezoneOffset: new Date().getTimezoneOffset(),

           // Debug info (fallback)
           consoleLogs: [...capturedLogs],
           networkLogs: [...networkLogs]
         };
       }
     }

            async function showVisualFeedback() {
       const modal = document.getElementById('visualFeedbackModal');
       const loading = document.getElementById('screenshotLoading');
       const main = document.getElementById('feedbackMain');
       
       // Gather system information first
       await gatherSystemInfo();
       
       // First, show modal with loading state
       modal.style.display = 'flex';
       loading.style.display = 'block';
       main.style.display = 'none';
       document.getElementById('loadingText').textContent = 'Preparing to capture...';
       
       // Wait a brief moment for the modal to render
       await new Promise(resolve => setTimeout(resolve, 100));
       
       // Update loading text and hide everything before taking screenshot
       document.getElementById('loadingText').textContent = 'Capturing screenshot...';
       await new Promise(resolve => setTimeout(resolve, 50));
       
       modal.style.display = 'none';
       document.querySelector('.help-button').style.display = 'none';
       
       try {
         // Take screenshot of clean page (without modal)
         const screenshotCanvas = await html2canvas(document.body, {
           useCORS: true,
           allowTaint: true,
           scale: 0.7,
           width: window.innerWidth,
           height: window.innerHeight
         });
         
         // Now show the modal again with the screenshot
         modal.style.display = 'flex';
         loading.style.display = 'block';
         main.style.display = 'none';
         document.getElementById('loadingText').textContent = 'Processing screenshot...';
         
         // Setup canvas for drawing
         canvas = document.getElementById('screenshotCanvas');
         ctx = canvas.getContext('2d');
         
         // Set canvas to 1:1 scale (original screenshot size)
         canvas.width = screenshotCanvas.width;
         canvas.height = screenshotCanvas.height;
         
         // Draw screenshot at original size (1:1 scale)
         ctx.drawImage(screenshotCanvas, 0, 0);
         
         // Store original image data for redrawing
         originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
         
         // Update dimensions display
         updateDimensionsDisplay(canvas.width, canvas.height);
         
         // Setup drawing event listeners
         setupDrawingEvents();
         
         // Initialize chat with system info
         initializeChat();
         
         // Show main content
         loading.style.display = 'none';
         main.style.display = 'flex';
        
             } catch (error) {
         console.error('Failed to take screenshot:', error);
         
         // Show modal again even if screenshot failed
         modal.style.display = 'flex';
         loading.innerHTML = '<p>Failed to take screenshot. Please describe your issue in the chat.</p>';
         
         setTimeout(() => {
           loading.style.display = 'none';
           main.style.display = 'flex';
         }, 2000);
       }
       
       // Restore help button
       document.querySelector('.help-button').style.display = 'block';
     }
     
     function updateDimensionsDisplay(width, height) {
       const display = document.getElementById('dimensionsDisplay');
       if (display) {
         display.textContent = `${width} √ó ${height}px`;
       }
     }
     
     function setupDrawingEvents() {
       // Keyboard shortcuts
       document.addEventListener('keydown', (e) => {
         // CTRL+Z for undo
         if (e.ctrlKey && e.key === 'z') {
           e.preventDefault();
           undoLastAnnotation();
         }
       });

       // Tool selection
       document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
         btn.addEventListener('click', (e) => {
           // Remove active from all tools
           document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
           // Add active to clicked tool
           e.target.classList.add('active');
           currentTool = e.target.dataset.tool;
           
           // Update cursor
           canvas.style.cursor = currentTool === 'pen' ? 'crosshair' : 'crosshair';
         });
       });
       
       // Color selection
       document.querySelectorAll('.color-option').forEach(colorBtn => {
         colorBtn.addEventListener('click', (e) => {
           // Remove active from all colors
           document.querySelectorAll('.color-option').forEach(c => c.classList.remove('active'));
           // Add active to clicked color
           e.target.classList.add('active');
           currentColor = e.target.dataset.color;
         });
       });
       
       // Drawing events
       canvas.addEventListener('mousedown', startDrawing);
       canvas.addEventListener('mousemove', draw);
       canvas.addEventListener('mouseup', stopDrawing);
       canvas.addEventListener('mouseout', stopDrawing);
       
       // Touch events for mobile
       canvas.addEventListener('touchstart', handleTouch);
       canvas.addEventListener('touchmove', handleTouch);
       canvas.addEventListener('touchend', stopDrawing);
     }
     
     function startDrawing(e) {
       isDrawing = true;
       const rect = canvas.getBoundingClientRect();
       startX = e.clientX - rect.left;
       startY = e.clientY - rect.top;
       
       if (currentTool === 'pen') {
         currentAnnotation = {
           type: 'pen',
           color: currentColor,
           points: [{x: startX, y: startY}]
         };
         
         ctx.beginPath();
         ctx.moveTo(startX, startY);
         ctx.strokeStyle = currentColor;
         ctx.lineWidth = 3;
         ctx.lineCap = 'round';
         ctx.lineJoin = 'round';
       }
     }
     
     function draw(e) {
       if (!isDrawing) return;
       
       const rect = canvas.getBoundingClientRect();
       const currentX = e.clientX - rect.left;
       const currentY = e.clientY - rect.top;
       
       if (currentTool === 'pen') {
         // Draw line segment
         ctx.lineTo(currentX, currentY);
         ctx.stroke();
         
         // Add point to current annotation
         currentAnnotation.points.push({x: currentX, y: currentY});
         
       } else if (currentTool === 'rectangle' || currentTool === 'arrow') {
         // Clear and redraw for shapes
         redrawCanvas();
         
         ctx.strokeStyle = currentColor;
         ctx.lineWidth = 3;
         
         if (currentTool === 'rectangle') {
           ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
         } else if (currentTool === 'arrow') {
           drawArrow(startX, startY, currentX, currentY);
         }
       }
     }
     
     function stopDrawing() {
       if (!isDrawing) return;
       isDrawing = false;
       
       if (currentTool === 'pen' && currentAnnotation) {
         annotations.push(currentAnnotation);
       } else if (currentTool === 'rectangle') {
         const rect = canvas.getBoundingClientRect();
         annotations.push({
           type: 'rectangle',
           color: currentColor,
           x: startX,
           y: startY,
           width: event.clientX - rect.left - startX,
           height: event.clientY - rect.top - startY
         });
       } else if (currentTool === 'arrow') {
         const rect = canvas.getBoundingClientRect();
         annotations.push({
           type: 'arrow',
           color: currentColor,
           startX: startX,
           startY: startY,
           endX: event.clientX - rect.left,
           endY: event.clientY - rect.top
         });
       }
       
       currentAnnotation = null;
     }
     
     function drawArrow(startX, startY, endX, endY) {
       const headLength = 15;
       const angle = Math.atan2(endY - startY, endX - startX);
       
       // Draw line
       ctx.beginPath();
       ctx.moveTo(startX, startY);
       ctx.lineTo(endX, endY);
       ctx.stroke();
       
       // Draw arrowhead
       ctx.beginPath();
       ctx.moveTo(endX, endY);
       ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
       ctx.moveTo(endX, endY);
       ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
       ctx.stroke();
     }
     
     function redrawCanvas() {
       // Clear canvas and restore original image
       ctx.putImageData(originalImageData, 0, 0);
       
       // Redraw all annotations
       annotations.forEach(annotation => {
         ctx.strokeStyle = annotation.color;
         ctx.lineWidth = 3;
         ctx.lineCap = 'round';
         ctx.lineJoin = 'round';
         
         if (annotation.type === 'pen') {
           ctx.beginPath();
           annotation.points.forEach((point, index) => {
             if (index === 0) {
               ctx.moveTo(point.x, point.y);
             } else {
               ctx.lineTo(point.x, point.y);
             }
           });
           ctx.stroke();
         } else if (annotation.type === 'rectangle') {
           ctx.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
         } else if (annotation.type === 'arrow') {
           drawArrow(annotation.startX, annotation.startY, annotation.endX, annotation.endY);
         }
       });
     }
     
     function clearAnnotations() {
       annotations = [];
       redrawCanvas();
     }
     
     function undoAnnotation() {
       annotations.pop();
       redrawCanvas();
     }

     function undoLastAnnotation() {
       undoAnnotation();
     }

     function initializeChat() {
       // Clear any existing messages
       const chatContainer = document.getElementById('chatMessages');
       chatContainer.innerHTML = '';
       chatMessages = [];

               // Add system info message
        if (systemInfo) {
          // Build console logs section
          let consoleLogsHtml = '';
          if (systemInfo.consoleLogs && systemInfo.consoleLogs.length > 0) {
            const logEntries = systemInfo.consoleLogs.map(log => {
              const time = new Date(log.timestamp).toLocaleTimeString();
              return `<div class="log-entry ${log.level}">
                <span class="log-timestamp">[${time}]</span> ${log.message}
              </div>`;
            }).join('');
            
            consoleLogsHtml = `
              <div class="log-section">
                <div class="log-header" onclick="toggleLogSection(this)">
                  <span>üñ•Ô∏è Console Logs (${systemInfo.consoleLogs.length})</span>
                  <span class="arrow">‚ñ∂</span>
                </div>
                <div class="log-content">
                  <div class="log-entries">${logEntries}</div>
                </div>
              </div>`;
          }

                     // Build network logs section
           let networkLogsHtml = '';
           if (systemInfo.networkLogs && systemInfo.networkLogs.length > 0) {
             const networkEntries = systemInfo.networkLogs.map((log, index) => {
               const time = new Date(log.timestamp).toLocaleTimeString();
               const statusClass = log.status === 'failed' ? 'error' : 
                                 log.status === 'pending' ? 'pending' : 'success';
               const duration = log.duration ? ` (${log.duration}ms)` : '';
               const size = log.size && log.size !== 'unknown' ? ` - ${log.size}b` : '';
               
               // Format request headers
               const requestHeaders = log.requestHeaders && Object.keys(log.requestHeaders).length > 0 ? 
                 Object.entries(log.requestHeaders).map(([key, value]) => `${key}: ${value}`).join('\n') : 
                 'No custom headers';
               
               // Format response headers
               const responseHeaders = log.responseHeaders && Object.keys(log.responseHeaders).length > 0 ? 
                 Object.entries(log.responseHeaders).map(([key, value]) => `${key}: ${value}`).join('\n') : 
                 'No response headers';
               
               // Format request body
               const requestBody = log.requestBody ? log.requestBody : 'No request body';
               
                                // Format response body
                 const responseBody = log.responseBody ? log.responseBody : 'No response body';
                 
                 // Generate curl command for replication
                 let curlCommand = `curl -X ${log.method} '${log.url}'`;
                 if (log.requestHeaders && Object.keys(log.requestHeaders).length > 0) {
                   Object.entries(log.requestHeaders).forEach(([key, value]) => {
                     curlCommand += ` \\\n  -H '${key}: ${value}'`;
                   });
                 }
                 if (log.requestBody) {
                   curlCommand += ` \\\n  -d '${log.requestBody}'`;
                 }
                 
                 // Generate JavaScript fetch command
                 let fetchCommand = `fetch('${log.url}', {
  method: '${log.method}'`;
                 
                 if (log.requestHeaders && Object.keys(log.requestHeaders).length > 0) {
                   fetchCommand += `,
  headers: {
${Object.entries(log.requestHeaders).map(([key, value]) => `    '${key}': '${value}'`).join(',\n')}
  }`;
                 }
                 
                 if (log.requestBody) {
                   fetchCommand += `,
  body: '${log.requestBody}'`;
                 }
                 
                 fetchCommand += `
}).then(response => response.text()).then(data => console.log(data));`;
                 
                 return `<div class="network-entry ${statusClass}">
                   <div class="network-main">
                     <span class="log-timestamp">[${time}]</span>
                     <span class="network-status">${log.method} ${log.status}</span>
                     <div class="network-url">${log.url}${duration}${size}</div>
                   </div>
                   <div class="network-details">
                     <div class="log-section" style="margin: 8px 0;">
                       <div class="log-header" onclick="toggleLogSection(this)" style="font-size: 11px; padding: 4px 8px;">
                         <span>üì§ Request Details</span>
                         <span class="arrow">‚ñ∂</span>
                       </div>
                       <div class="log-content">
                         <div class="log-entries" style="padding: 8px;">
                           <div class="log-entry log">
                             <strong>Headers:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${requestHeaders}</pre>
                             <strong>Body:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${requestBody}</pre>
                           </div>
                         </div>
                       </div>
                     </div>
                     <div class="log-section" style="margin: 8px 0;">
                       <div class="log-header" onclick="toggleLogSection(this)" style="font-size: 11px; padding: 4px 8px;">
                         <span>üì• Response Details</span>
                         <span class="arrow">‚ñ∂</span>
                       </div>
                       <div class="log-content">
                         <div class="log-entries" style="padding: 8px;">
                           <div class="log-entry log">
                             <strong>Headers:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${responseHeaders}</pre>
                             <strong>Body:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${responseBody}</pre>
                           </div>
                         </div>
                       </div>
                     </div>
                     <div class="log-section" style="margin: 8px 0;">
                       <div class="log-header" onclick="toggleLogSection(this)" style="font-size: 11px; padding: 4px 8px;">
                         <span>üîÑ Curl Command</span>
                         <span class="arrow">‚ñ∂</span>
                       </div>
                       <div class="log-content">
                         <div class="log-entries" style="padding: 8px;">
                           <div class="log-entry log">
                             <strong>Copy & paste to terminal:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${curlCommand}</pre>
                           </div>
                         </div>
                       </div>
                     </div>
                     <div class="log-section" style="margin: 8px 0;">
                       <div class="log-header" onclick="toggleLogSection(this)" style="font-size: 11px; padding: 4px 8px;">
                         <span>üü® JavaScript Code</span>
                         <span class="arrow">‚ñ∂</span>
                       </div>
                       <div class="log-content">
                         <div class="log-entries" style="padding: 8px;">
                           <div class="log-entry log">
                             <strong>Copy & paste to browser console:</strong><br/>
                             <pre style="margin: 4px 0; font-size: 10px;">${fetchCommand}</pre>
                           </div>
                         </div>
                       </div>
                     </div>
                   </div>
                 </div>`;
             }).join('');
             
             networkLogsHtml = `
               <div class="log-section">
                 <div class="log-header" onclick="toggleLogSection(this)">
                   <span>üåê Network Logs (${systemInfo.networkLogs.length})</span>
                   <span class="arrow">‚ñ∂</span>
                 </div>
                 <div class="log-content">
                   <div class="log-entries">${networkEntries}</div>
                 </div>
               </div>`;
           }

          // Build session info section
          const sessionInfoHtml = `
            <div class="log-section">
              <div class="log-header" onclick="toggleLogSection(this)">
                <span>üìã Session Information</span>
                <span class="arrow">‚ñ∂</span>
              </div>
              <div class="log-content">
                <div class="log-entries">
                  <div class="log-entry log">
                    üìç <strong>URL:</strong> ${systemInfo.url}<br/>
                    üåê <strong>Browser:</strong> ${systemInfo.browser} ${systemInfo.browserVersion}<br/>
                    üíª <strong>OS:</strong> ${systemInfo.os} (${systemInfo.platform})<br/>
                    üì± <strong>Viewport:</strong> ${systemInfo.viewportWidth}√ó${systemInfo.viewportHeight} (Screen: ${systemInfo.screenWidth}√ó${systemInfo.screenHeight})<br/>
                    üåç <strong>IP:</strong> ${systemInfo.ip}<br/>
                    üó£Ô∏è <strong>Language:</strong> ${systemInfo.language}<br/>
                    ‚è∞ <strong>Timezone:</strong> ${systemInfo.timezone}<br/>
                    ${systemInfo.touchSupported ? 'üëÜ <strong>Touch Device</strong><br/>' : ''}
                    ${systemInfo.connectionType !== 'Unknown' ? `üì∂ <strong>Connection:</strong> ${systemInfo.connectionType}<br/>` : ''}
                  </div>
                </div>
              </div>
            </div>`;

          const systemMessage = `${sessionInfoHtml}
${consoleLogsHtml}
${networkLogsHtml}
<br/>Hi! I can see you've taken a screenshot. Please describe what issue you're experiencing or what help you need.`;
          
          addChatMessage('ai', systemMessage);
       } else {
         // Fallback message if system info failed
         addChatMessage('ai', "Hi! I can see you've taken a screenshot. Please describe what issue you're experiencing or what help you need.");
       }
           }

      function toggleLogSection(header) {
        const content = header.nextElementSibling;
        const arrow = header.querySelector('.arrow');
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          header.classList.remove('expanded');
        } else {
          content.classList.add('expanded');
          header.classList.add('expanded');
        }
      }

      function submitFeedback() {
        // Prepare feedback data
        const feedbackData = {
          systemInfo: systemInfo,
          annotations: annotations,
          chatMessages: chatMessages.filter(m => m.type === 'user'),
          screenshot: canvas ? canvas.toDataURL('image/png') : null,
          replicationData: systemInfo?.replicationData || null,
          submittedAt: new Date().toISOString()
        };

        console.log('Feedback Data to Submit:', feedbackData);
        
        // Here you would normally send to your backend
        // Example: 
        // fetch('/api/feedback', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json' },
        //   body: JSON.stringify(feedbackData)
        // });

        const replicationInfo = systemInfo?.replicationData ? `
‚Ä¢ üé¨ Screen Recording: ${Math.round(systemInfo.replicationData.duration / 1000)}s video (${Math.round(systemInfo.replicationData.videoBlob.size / 1024)}KB)
‚Ä¢ üìù Replication Steps: ${systemInfo.replicationData.steps.length} interactions tracked` : '';

        alert(`Feedback submitted successfully! 

üìã Data captured includes:
‚Ä¢ üåê Browser: ${systemInfo.browser} ${systemInfo.browserVersion}
‚Ä¢ üíª System: ${systemInfo.os} (${systemInfo.platform})
‚Ä¢ üì± Display: ${systemInfo.viewportWidth}√ó${systemInfo.viewportHeight} @ ${systemInfo.devicePixelRatio}x DPI
‚Ä¢ üåç Network: ${systemInfo.ip} (${systemInfo.connectionType})
‚Ä¢ üìç Page: ${systemInfo.url}
‚Ä¢ üó£Ô∏è Language: ${systemInfo.language}
‚Ä¢ ‚è∞ Timezone: ${systemInfo.timezone}
${systemInfo.touchSupported ? '‚Ä¢ üëÜ Touch device detected\n' : ''}
‚Ä¢ üì∏ Screenshot: Full resolution (${canvas ? canvas.width + '√ó' + canvas.height : 'N/A'})
‚Ä¢ ‚úèÔ∏è Annotations: ${annotations.length} drawings
‚Ä¢ üí¨ Messages: ${chatMessages.filter(m => m.type === 'user').length} user messages
‚Ä¢ üñ•Ô∏è Console Logs: ${systemInfo.consoleLogs ? systemInfo.consoleLogs.length : 0} entries
‚Ä¢ üåê Network Logs: ${systemInfo.networkLogs ? systemInfo.networkLogs.length : 0} requests (with headers, body & curl commands)${replicationInfo}

Thank you for your detailed feedback!`);
        
        hideVisualFeedback();
      }
      
       function handleTouch(e) {
       e.preventDefault();
       const touch = e.touches[0];
       const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                         e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
         clientX: touch.clientX,
         clientY: touch.clientY
       });
       canvas.dispatchEvent(mouseEvent);
     }
     
          function hideVisualFeedback() {
       // Stop any active recording
       if (isRecording) {
         stopReplication();
       }
       
       document.getElementById('visualFeedbackModal').style.display = 'none';
       
       // Clear chat input
       document.getElementById('chatInput').value = '';
       
       // Reset drawing state
       annotations = [];
       currentAnnotation = null;
       isDrawing = false;
       originalImageData = null;
       systemInfo = null;
       
               // Reset replication state
        replicationSteps = [];
        recordedChunks = [];
        document.getElementById('stepsList').innerHTML = '';
        document.getElementById('startRecordingBtn').style.display = 'inline-flex';
        document.getElementById('stopRecordingBtn').style.display = 'none';
        document.getElementById('recordingStatus').style.display = 'none';
        document.getElementById('stopRecordingFloating').style.display = 'none';
     }
    
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      addChatMessage('user', message);
      input.value = '';
      
      // Simulate AI response
      setTimeout(() => {
        const responses = [
          "Thank you for the description. I can see the issue in the screenshot. Is there anything specific you'd like us to focus on?",
          "I understand the problem. Can you tell me what you expected to happen instead?",
          "That's helpful information. Let me create a ticket for you with this visual feedback.",
          "Perfect! I have all the information I need. Your feedback has been submitted successfully."
        ];
        
        const response = responses[Math.min(chatMessages.filter(m => m.type === 'user').length - 1, responses.length - 1)];
        addChatMessage('ai', response);
        
        // Auto-submit after 3rd user message
        if (chatMessages.filter(m => m.type === 'user').length >= 3) {
          setTimeout(() => {
            submitFeedback();
          }, 2000);
        }
      }, 1000);
    }
    
    function addChatMessage(type, message) {
      const chatContainer = document.getElementById('chatMessages');
      const messageEl = document.createElement('div');
      messageEl.className = type + '-message';
      
      if (type === 'user') {
        messageEl.innerHTML = `
          <div class="message-content">
            <p>${message}</p>
          </div>
          <div class="message-avatar">üë§</div>
        `;
        messageEl.style.flexDirection = 'row-reverse';
        messageEl.querySelector('.message-content').style.backgroundColor = '#3b82f6';
        messageEl.querySelector('.message-content').style.color = 'white';
      } else {
        messageEl.innerHTML = `
          <div class="message-avatar">ü§ñ</div>
          <div class="message-content">
            <div>${message}</div>
          </div>
        `;
      }
      
      chatContainer.appendChild(messageEl);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      
      chatMessages.push({ type, message });
    }
    
    // Allow Enter to send message
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    
    // Close modal when clicking outside
    document.getElementById('visualFeedbackModal').addEventListener('click', (e) => {
      if (e.target.id === 'visualFeedbackModal') {
        hideVisualFeedback();
      }
    });

    // Test console logging to verify capture is working
    console.log('Visual Feedback Widget initialized successfully');
    console.info('Console and network monitoring is active');
    
    // Test network monitoring with a small request
    fetch('/api/test-endpoint', { 
      method: 'POST', 
      headers: {
        'Content-Type': 'application/json',
        'X-Custom-Header': 'widget-test',
        'Authorization': 'Bearer demo-token'
      },
      body: JSON.stringify({
        test: true,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        action: 'widget_initialization'
      })
    }).catch(() => console.warn('Test network request failed (expected)'));
  </script>
</body>
</html> 